

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>epyr.baseline._1d &mdash; EPyR Tools v0.1.0 Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            EPyR Tools
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/epyr.html">EPyR Tools API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">Complete Module Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">EPyR Tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">epyr.baseline._1d</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for epyr.baseline._1d</h1><div class="highlight"><pre>
<span></span><span class="c1"># epyrtools/baseline/_1d.py</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">1D Baseline Correction Algorithms</span>
<span class="sd">=================================</span>

<span class="sd">This module contains the core functions for performing baseline correction on</span>
<span class="sd">1D data arrays. These functions are exposed to the user through the</span>
<span class="sd">`epyrtools.baseline` sub-package.</span>

<span class="sd">It includes polynomial, constant offset, and exponential decay models.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">curve_fit</span>

<span class="c1"># Import shared utility functions from within the same sub-package</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_create_fit_mask</span>

<span class="c1"># --- Model Functions for Curve Fitting ---</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_stretched_exponential_decay_model</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Model: y0 + amplitude * exp(-(t / tau)**beta).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tau</span> <span class="o">&lt;=</span> <span class="mf">1e-12</span><span class="p">:</span>  <span class="c1"># Prevent division by zero or extremely small tau</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">1e-3</span> <span class="o">&lt;</span> <span class="n">beta</span> <span class="o">&lt;=</span> <span class="mf">5.0001</span><span class="p">):</span>  <span class="c1"># Beta is typically 0 &lt; beta &lt;= 3</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">decay_arg</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="n">tau</span>
    <span class="c1"># Ensure argument to exponentiation is non-negative</span>
    <span class="n">decay_arg_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">decay_arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">decay_arg_safe</span><span class="p">)</span> <span class="o">**</span> <span class="n">beta</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_mono_exponential_decay_model</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Model: y0 + amplitude * exp(-t / tau).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tau</span> <span class="o">&lt;=</span> <span class="mf">1e-12</span><span class="p">:</span>  <span class="c1"># Prevent division by zero or extremely small tau</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">return</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>


<span class="c1"># --- Heuristic Initial Guess Generators for Exponential Models ---</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_heuristic_stretched_exp_guess</span><span class="p">(</span><span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a heuristic initial guess for a stretched exponential fit.&quot;&quot;&quot;</span>
    <span class="n">guess_y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
        <span class="n">y_masked</span><span class="p">[</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_masked</span><span class="p">)</span> <span class="o">//</span> <span class="mi">20</span><span class="p">)</span> <span class="p">:]</span>
    <span class="p">)</span>  <span class="c1"># Offset is mean of tail</span>
    <span class="n">guess_A</span> <span class="o">=</span> <span class="n">y_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">guess_y0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_masked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1"># Amplitude</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_masked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x_masked</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">guess_tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_masked</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.0</span>  <span class="c1"># Decay time is ~1/3 of range</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">guess_tau</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">guess_beta</span> <span class="o">=</span> <span class="mf">0.8</span>  <span class="c1"># Common value for stretched exponential</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">guess_y0</span><span class="p">,</span> <span class="n">guess_A</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">guess_tau</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">),</span> <span class="n">guess_beta</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_heuristic_mono_exp_guess</span><span class="p">(</span><span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a heuristic initial guess for a mono-exponential fit.&quot;&quot;&quot;</span>
    <span class="n">guess_y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_masked</span><span class="p">[</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_masked</span><span class="p">)</span> <span class="o">//</span> <span class="mi">20</span><span class="p">)</span> <span class="p">:])</span>
    <span class="n">guess_A</span> <span class="o">=</span> <span class="n">y_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">guess_y0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_masked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_masked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x_masked</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">guess_tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_masked</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">guess_tau</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">guess_y0</span><span class="p">,</span> <span class="n">guess_A</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">guess_tau</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">)]</span>


<span class="c1"># --- Exponential Baseline Core Logic ---</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_fit_exponential_baseline</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">model_func</span><span class="p">,</span>
    <span class="n">param_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">default_initial_guess_generator</span><span class="p">,</span>
    <span class="n">default_bounds</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
    <span class="n">user_initial_guess</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">user_bounds</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fit_region</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A generic helper to fit an exponential-like baseline model.&quot;&quot;&quot;</span>
    <span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">y_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y_data must be a 1D NumPy array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> requires x_data as a 1D NumPy array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_data and y_data must have the same length.&quot;</span><span class="p">)</span>

    <span class="c1"># Validate region formats</span>
    <span class="k">if</span> <span class="n">fit_region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">fit_region</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fit_region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fit_region must be a (start_x, end_x) tuple.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exclude_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;exclude_regions must be a list of (start_x, end_x) tuples.&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Each item in exclude_regions (item </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">) must be a (start_x, end_x) tuple.&quot;</span>
                <span class="p">)</span>

    <span class="n">fit_mask</span> <span class="o">=</span> <span class="n">_create_fit_mask</span><span class="p">(</span>
        <span class="n">x_data</span><span class="p">,</span> <span class="n">fit_window</span><span class="o">=</span><span class="n">fit_region</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude_regions</span>
    <span class="p">)</span>
    <span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span> <span class="o">=</span> <span class="n">x_data</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_masked</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_params</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Not enough points (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x_masked</span><span class="p">)</span><span class="si">}</span><span class="s2">) to fit </span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">n_params</span><span class="si">}</span><span class="s2"> parameters after applying regions. &quot;</span>
            <span class="s2">&quot;Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="kc">None</span>

    <span class="c1"># Handle initial guess</span>
    <span class="k">if</span> <span class="n">user_initial_guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">current_initial_guess</span> <span class="o">=</span> <span class="n">default_initial_guess_generator</span><span class="p">(</span><span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span><span class="p">)</span>
        <span class="n">param_order_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Using heuristic initial guess for </span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;([</span><span class="si">{</span><span class="n">param_order_str</span><span class="si">}</span><span class="s2">]): </span><span class="si">{</span><span class="n">current_initial_guess</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_initial_guess</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_initial_guess</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_params</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;initial_guess must be a list/array of </span><span class="si">{</span><span class="n">n_params</span><span class="si">}</span><span class="s2"> values.&quot;</span>
            <span class="p">)</span>
        <span class="n">current_initial_guess</span> <span class="o">=</span> <span class="n">user_initial_guess</span>

    <span class="c1"># Handle parameter bounds</span>
    <span class="n">current_bounds</span> <span class="o">=</span> <span class="n">default_bounds</span>
    <span class="k">if</span> <span class="n">user_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_bounds</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">n_params</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">n_params</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;bounds must be a tuple of two lists/arrays of length </span><span class="si">{</span><span class="n">n_params</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="s2">&quot;([lowers], [uppers])&quot;</span>
            <span class="p">)</span>
        <span class="n">current_bounds</span> <span class="o">=</span> <span class="n">user_bounds</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
            <span class="n">model_func</span><span class="p">,</span>
            <span class="n">x_masked</span><span class="p">,</span>
            <span class="n">y_masked</span><span class="p">,</span>
            <span class="n">p0</span><span class="o">=</span><span class="n">current_initial_guess</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">current_bounds</span><span class="p">,</span>
            <span class="n">maxfev</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;trf&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="n">model_func</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="n">y_corrected</span> <span class="o">=</span> <span class="n">y_data</span> <span class="o">-</span> <span class="n">baseline</span>

        <span class="c1"># Calculate parameter standard errors from covariance matrix</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">pcov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">perr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">perr</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_params</span>
            <span class="k">if</span> <span class="n">pcov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Covariance matrix from fit is problematic. Std errors set to NaN.&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Compile results into a dictionary</span>
        <span class="n">fit_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="n">param_names</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">popt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_params</span><span class="p">)}</span>
        <span class="n">fit_parameters</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;std_</span><span class="si">{</span><span class="n">param_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">perr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_params</span><span class="p">)}</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">y_corrected</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">fit_parameters</span>

    <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fit did not converge: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;ValueError during </span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fit: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected error in </span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fit: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="kc">None</span>


<span class="c1"># --- Public 1D Baseline Correction Functions ---</span>


<div class="viewcode-block" id="baseline_polynomial">
<a class="viewcode-back" href="../../../api/generated/epyr.baseline.html#epyr.baseline._1d.baseline_polynomial">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">baseline_polynomial</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">poly_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">roi</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs baseline correction by subtracting a polynomial fit.</span>

<span class="sd">    The polynomial is fitted to specific regions of the data, which are</span>
<span class="sd">    presumed to contain only the baseline. These regions are defined by</span>
<span class="sd">    specifying an overall Region of Interest (ROI) and/or by excluding regions</span>
<span class="sd">    that contain signals (e.g., peaks).</span>

<span class="sd">    Args:</span>
<span class="sd">        y_data (np.ndarray): The 1D spectral data array.</span>
<span class="sd">        x_data (np.ndarray, optional): The x-axis data corresponding to y_data.</span>
<span class="sd">            If provided, `roi` and `exclude_regions` are interpreted in the</span>
<span class="sd">            units of `x_data`. If None, array indices are used. Defaults to None.</span>
<span class="sd">        poly_order (int, optional): Order of the polynomial to fit.</span>
<span class="sd">            Defaults to 1 (a linear fit).</span>
<span class="sd">        exclude_regions (list of tuples, optional): A list of `(start, end)`</span>
<span class="sd">            tuples specifying regions to *exclude* from the baseline fit.</span>
<span class="sd">            Interpreted in `x_data` units or indices. Defaults to None.</span>
<span class="sd">        roi (tuple, optional): A single `(start, end)` tuple specifying the</span>
<span class="sd">            Region of Interest where baseline fitting should *occur*. Data outside</span>
<span class="sd">            this ROI (and within `exclude_regions`) will not be used. If None,</span>
<span class="sd">            the entire dataset (minus `exclude_regions`) is used.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - **y_corrected** (np.ndarray): The baseline-corrected `y_data`.</span>
<span class="sd">            - **baseline** (np.ndarray): The calculated polynomial baseline.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If inputs are invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">y_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y_data must be a 1D NumPy array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">poly_order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;poly_order must be a non-negative integer.&quot;</span><span class="p">)</span>

    <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_data</span><span class="p">)</span>

    <span class="c1"># Determine the reference axis for fitting and evaluation</span>
    <span class="k">if</span> <span class="n">x_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_data must be a 1D NumPy array if provided.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_points</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_data and y_data must have the same length.&quot;</span><span class="p">)</span>
        <span class="n">reference_axis</span> <span class="o">=</span> <span class="n">x_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reference_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>

    <span class="c1"># Validate region formats</span>
    <span class="k">if</span> <span class="n">roi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;roi must be a tuple of (start, end).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exclude_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exclude_regions must be a list of (start, end) tuples.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Each item in exclude_regions (item </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">) must be a (start, end) tuple.&quot;</span>
                <span class="p">)</span>

    <span class="c1"># Create the mask for points to include in the fit using the shared utility</span>
    <span class="n">fit_mask</span> <span class="o">=</span> <span class="n">_create_fit_mask</span><span class="p">(</span>
        <span class="n">reference_axis</span><span class="p">,</span> <span class="n">fit_window</span><span class="o">=</span><span class="n">roi</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude_regions</span>
    <span class="p">)</span>

    <span class="n">num_points_for_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fit_mask</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_points_for_fit</span> <span class="o">&lt;=</span> <span class="n">poly_order</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Not enough points (</span><span class="si">{</span><span class="n">num_points_for_fit</span><span class="si">}</span><span class="s2">) for polynomial fit of &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;order </span><span class="si">{</span><span class="n">poly_order</span><span class="si">}</span><span class="s2"> after applying ROI/exclusions. &quot;</span>
            <span class="s2">&quot;Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Fit polynomial using only the masked (True) points</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">reference_axis</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">],</span> <span class="n">poly_order</span><span class="p">)</span>
        <span class="c1"># Evaluate the polynomial over the entire original axis</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">reference_axis</span><span class="p">)</span>
        <span class="n">y_corrected</span> <span class="o">=</span> <span class="n">y_data</span> <span class="o">-</span> <span class="n">baseline</span>
        <span class="k">return</span> <span class="n">y_corrected</span><span class="p">,</span> <span class="n">baseline</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Polynomial baseline fit failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">)</span></div>



<div class="viewcode-block" id="baseline_constant_offset">
<a class="viewcode-back" href="../../../api/generated/epyr.baseline.html#epyr.baseline._1d.baseline_constant_offset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">baseline_constant_offset</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">offset_region_indices</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs baseline correction by subtracting a constant offset.</span>

<span class="sd">    The offset is calculated from a specified region of `y_data` (using</span>
<span class="sd">    array indices) via its mean or median.</span>

<span class="sd">    Args:</span>
<span class="sd">        y_data (np.ndarray): The 1D spectral data array.</span>
<span class="sd">        offset_region_indices (tuple, optional): A `(start_index, end_index)`</span>
<span class="sd">            tuple specifying the slice of `y_data` (exclusive of `end_index`)</span>
<span class="sd">            to calculate the offset from. If None, the entire array is used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        method (str, optional): The method to calculate the offset. Can be</span>
<span class="sd">            &#39;mean&#39; or &#39;median&#39;. Defaults to &#39;mean&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - **y_corrected** (np.ndarray): The baseline-corrected `y_data`.</span>
<span class="sd">            - **baseline** (np.ndarray): The calculated constant baseline array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If inputs are invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">y_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y_data must be a 1D NumPy array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method must be &#39;mean&#39; or &#39;median&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Determine the slice of data to use for offset calculation</span>
    <span class="k">if</span> <span class="n">offset_region_indices</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset_region_indices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset_region_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;offset_region_indices must be a (start_index, end_index) tuple.&quot;</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">offset_region_indices</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;offset_region_indices components must be convertible to int.&quot;</span>
            <span class="p">)</span>

        <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">)</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="n">end_idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_idx</span> <span class="o">&gt;=</span> <span class="n">end_idx</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid offset_region_indices (</span><span class="si">{</span><span class="n">offset_region_indices</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;Start index must be less than end index. Using whole array.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">region_for_offset</span> <span class="o">=</span> <span class="n">y_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">region_for_offset</span> <span class="o">=</span> <span class="n">y_data</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;offset_region_indices not provided. Using whole array for offset.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">region_for_offset</span> <span class="o">=</span> <span class="n">y_data</span>

    <span class="k">if</span> <span class="n">region_for_offset</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Offset calculation region is empty. Returning original data.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">)</span>

    <span class="c1"># Calculate the offset value</span>
    <span class="n">offset_value</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">region_for_offset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span>
        <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">region_for_offset</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">offset_value</span><span class="p">)</span>
    <span class="n">y_corrected</span> <span class="o">=</span> <span class="n">y_data</span> <span class="o">-</span> <span class="n">offset_value</span>
    <span class="k">return</span> <span class="n">y_corrected</span><span class="p">,</span> <span class="n">baseline</span></div>



<div class="viewcode-block" id="baseline_stretched_exponential">
<a class="viewcode-back" href="../../../api/generated/epyr.baseline.html#epyr.baseline._1d.baseline_stretched_exponential">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">baseline_stretched_exponential</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">initial_guess</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fit_region</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fits and subtracts a stretched exponential decay baseline.</span>

<span class="sd">    The model fitted is: ``y(x) = y0 + A * exp(-((x / )**))``</span>

<span class="sd">    Args:</span>
<span class="sd">        y_data (np.ndarray): The 1D spectral data array.</span>
<span class="sd">        x_data (np.ndarray): The x-axis data corresponding to y_data.</span>
<span class="sd">        initial_guess (list, optional): A list of initial guess values for the</span>
<span class="sd">            parameters `[y0, A, tau, beta]`. If None, a heuristic guess is</span>
<span class="sd">            generated. Defaults to None.</span>
<span class="sd">        bounds (tuple, optional): A tuple `([lowers], [uppers])` for parameter</span>
<span class="sd">            bounds. Defaults to `([-inf, -inf, 1e-12, 1e-3], [inf, inf, inf, 5.0])`.</span>
<span class="sd">        fit_region (tuple, optional): A `(start, end)` tuple specifying the region</span>
<span class="sd">            in `x_data` units to use for fitting. Defaults to the whole range.</span>
<span class="sd">        exclude_regions (list of tuples, optional): A list of `(start, end)`</span>
<span class="sd">            tuples to *exclude* from the fit. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray, dict | None]:</span>
<span class="sd">            A tuple containing the corrected data, the baseline, and a dictionary</span>
<span class="sd">            of fit parameters. Returns `None` for parameters if the fit fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;y0&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;tau&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">]</span>
    <span class="n">default_bounds</span> <span class="o">=</span> <span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">_fit_exponential_baseline</span><span class="p">(</span>
        <span class="n">y_data</span><span class="p">,</span>
        <span class="n">x_data</span><span class="p">,</span>
        <span class="n">_stretched_exponential_decay_model</span><span class="p">,</span>
        <span class="n">param_names</span><span class="p">,</span>
        <span class="n">_heuristic_stretched_exp_guess</span><span class="p">,</span>
        <span class="n">default_bounds</span><span class="p">,</span>
        <span class="n">user_initial_guess</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">,</span>
        <span class="n">user_bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">fit_region</span><span class="o">=</span><span class="n">fit_region</span><span class="p">,</span>
        <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude_regions</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="baseline_mono_exponential">
<a class="viewcode-back" href="../../../api/generated/epyr.baseline.html#epyr.baseline._1d.baseline_mono_exponential">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">baseline_mono_exponential</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">initial_guess</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fit_region</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fits and subtracts a mono-exponential decay baseline.</span>

<span class="sd">    The model fitted is: ``y(x) = y0 + A * exp(-(x / ))``</span>

<span class="sd">    Args:</span>
<span class="sd">        y_data (np.ndarray): The 1D spectral data array.</span>
<span class="sd">        x_data (np.ndarray): The x-axis data corresponding to y_data.</span>
<span class="sd">        initial_guess (list, optional): A list of initial guess values for the</span>
<span class="sd">            parameters `[y0, A, tau]`. If None, a heuristic guess is generated.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        bounds (tuple, optional): A tuple `([lowers], [uppers])` for parameter</span>
<span class="sd">            bounds. Defaults to `([-inf, -inf, 1e-12], [inf, inf, inf])`.</span>
<span class="sd">        fit_region (tuple, optional): A `(start, end)` tuple specifying the region</span>
<span class="sd">            in `x_data` units to use for fitting. Defaults to the whole range.</span>
<span class="sd">        exclude_regions (list of tuples, optional): A list of `(start, end)`</span>
<span class="sd">            tuples to *exclude* from the fit. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray, dict | None]:</span>
<span class="sd">            A tuple containing the corrected data, the baseline, and a dictionary</span>
<span class="sd">            of fit parameters. Returns `None` for parameters if the fit fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;y0&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;tau&quot;</span><span class="p">]</span>
    <span class="n">default_bounds</span> <span class="o">=</span> <span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">_fit_exponential_baseline</span><span class="p">(</span>
        <span class="n">y_data</span><span class="p">,</span>
        <span class="n">x_data</span><span class="p">,</span>
        <span class="n">_mono_exponential_decay_model</span><span class="p">,</span>
        <span class="n">param_names</span><span class="p">,</span>
        <span class="n">_heuristic_mono_exp_guess</span><span class="p">,</span>
        <span class="n">default_bounds</span><span class="p">,</span>
        <span class="n">user_initial_guess</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">,</span>
        <span class="n">user_bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">fit_region</span><span class="o">=</span><span class="n">fit_region</span><span class="p">,</span>
        <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude_regions</span><span class="p">,</span>
    <span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Sylvain Bertaina.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>