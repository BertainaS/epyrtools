

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>epyr.sub.baseline2 &mdash; EPyR Tools v0.1.0 Documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            EPyR Tools
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/epyr.html">EPyR Tools API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">Complete Module Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">EPyR Tools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">epyr.sub.baseline2</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for epyr.sub.baseline2</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Baseline Correction Utilities</span>
<span class="sd">=============================</span>

<span class="sd">This module provides a suite of functions for performing baseline correction on</span>
<span class="sd">1D and 2D data. It is designed primarily for spectroscopic and imaging data where</span>
<span class="sd">unwanted background signals need to be removed.</span>

<span class="sd">Available Correction Methods:</span>
<span class="sd">-----------------------------</span>
<span class="sd">- **Polynomial**: Fits and subtracts a polynomial of a given order. (1D and 2D)</span>
<span class="sd">- **Constant Offset**: Subtracts a constant value calculated from a specified region. (1D)</span>
<span class="sd">- **Exponential Decay**: Fits and subtracts a mono-exponential or stretched-exponential</span>
<span class="sd">  decay curve, useful for signals with a decaying background (e.g., in time-resolved</span>
<span class="sd">  spectroscopy). (1D)</span>

<span class="sd">Core Functionality:</span>
<span class="sd">-------------------</span>
<span class="sd">The functions generally operate by fitting a model to user-specified &#39;baseline&#39;</span>
<span class="sd">regions of the data. These regions can be defined either by providing an</span>
<span class="sd">overall Region of Interest (ROI) for the fit, by explicitly excluding signal</span>
<span class="sd">regions, or both. The fitted model is then subtracted from the entire dataset.</span>

<span class="sd">Dependencies:</span>
<span class="sd">-------------</span>
<span class="sd">- NumPy: For all numerical operations and data handling.</span>
<span class="sd">- SciPy: Used for the non-linear curve fitting required by exponential models.</span>
<span class="sd">- Matplotlib (optional, for examples): Used to visualize the results of the</span>
<span class="sd">  example functions.</span>

<span class="sd">Usage:</span>
<span class="sd">------</span>
<span class="sd">To run the built-in examples and see the functions in action, execute the script</span>
<span class="sd">directly from the command line:</span>
<span class="sd">    $ python your_script_name.py</span>

<span class="sd">To run the unit tests:</span>
<span class="sd">    The tests are run automatically after the examples when the script is executed.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">unittest</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="c1"># For examples and tests:</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">curve_fit</span>

<span class="c1"># --- Helper Function for Masking ---</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_create_fit_mask</span><span class="p">(</span>
    <span class="n">reference_axis</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fit_window</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a boolean mask for data points to be used in 1D fitting.</span>

<span class="sd">    This helper function constructs a 1D boolean array where `True` values</span>
<span class="sd">    indicate which data points should be included in a fitting procedure.</span>

<span class="sd">    Args:</span>
<span class="sd">        reference_axis (np.ndarray): The axis (e.g., x-values or indices)</span>
<span class="sd">            against which `fit_window` and `exclude_regions` are defined.</span>
<span class="sd">        fit_window (tuple, optional): A `(start, end)` tuple specifying the</span>
<span class="sd">            primary region for fitting. Points outside this window are</span>
<span class="sd">            excluded. If None, the full range of `reference_axis` is</span>
<span class="sd">            initially considered. Defaults to None.</span>
<span class="sd">        exclude_regions (list of tuples, optional): A list of `(start, end)`</span>
<span class="sd">            tuples specifying regions to *exclude* from the fitting mask.</span>
<span class="sd">            These are applied after the `fit_window`. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            A boolean mask with the same size as `reference_axis`, where `True`</span>
<span class="sd">            indicates a point to include in the fit.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_axis</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># Apply the primary fit window (ROI) first</span>
    <span class="k">if</span> <span class="n">fit_window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">start_fw</span><span class="p">,</span> <span class="n">end_fw</span> <span class="o">=</span> <span class="n">fit_window</span>
        <span class="k">if</span> <span class="n">start_fw</span> <span class="o">&gt;=</span> <span class="n">end_fw</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Fit window start (</span><span class="si">{</span><span class="n">start_fw</span><span class="si">}</span><span class="s2">) is not less than its end &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">end_fw</span><span class="si">}</span><span class="s2">). The window will be ignored, and the full range &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;considered (before exclusions).&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">reference_axis</span> <span class="o">&gt;=</span> <span class="n">start_fw</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">reference_axis</span> <span class="o">&lt;=</span> <span class="n">end_fw</span><span class="p">)</span>

    <span class="c1"># Apply exclusions on top of the current mask</span>
    <span class="k">if</span> <span class="n">exclude_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">region_idx</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">):</span>
            <span class="n">start_ex</span><span class="p">,</span> <span class="n">end_ex</span> <span class="o">=</span> <span class="n">region</span>
            <span class="k">if</span> <span class="n">start_ex</span> <span class="o">&gt;=</span> <span class="n">end_ex</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Exclusion region #</span><span class="si">{</span><span class="n">region_idx</span><span class="si">}</span><span class="s2"> start (</span><span class="si">{</span><span class="n">start_ex</span><span class="si">}</span><span class="s2">) is not &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;less than its end (</span><span class="si">{</span><span class="n">end_ex</span><span class="si">}</span><span class="s2">). This region will be ignored.&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># The ~ operator inverts the boolean mask for the exclusion region</span>
            <span class="n">mask</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">((</span><span class="n">reference_axis</span> <span class="o">&gt;=</span> <span class="n">start_ex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">reference_axis</span> <span class="o">&lt;=</span> <span class="n">end_ex</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mask</span>


<span class="c1"># --- 1D Baseline Correction Functions ---</span>


<div class="viewcode-block" id="baseline_polynomial">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.baseline_polynomial">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">baseline_polynomial</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">poly_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">roi</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs baseline correction by subtracting a polynomial fit.</span>

<span class="sd">    The polynomial is fitted to specific regions of the data, which are</span>
<span class="sd">    presumed to contain only the baseline. These regions are defined by</span>
<span class="sd">    specifying an overall Region of Interest (ROI) and/or by excluding regions</span>
<span class="sd">    that contain signals (e.g., peaks).</span>

<span class="sd">    Args:</span>
<span class="sd">        y_data (np.ndarray): The 1D spectral data array.</span>
<span class="sd">        x_data (np.ndarray, optional): The x-axis data corresponding to y_data.</span>
<span class="sd">            If provided, `roi` and `exclude_regions` are interpreted in the</span>
<span class="sd">            units of `x_data`. If None, array indices are used. Defaults to None.</span>
<span class="sd">        poly_order (int, optional): Order of the polynomial to fit.</span>
<span class="sd">            Defaults to 1 (a linear fit).</span>
<span class="sd">        exclude_regions (list of tuples, optional): A list of `(start, end)`</span>
<span class="sd">            tuples specifying regions to *exclude* from the baseline fit.</span>
<span class="sd">            Interpreted in `x_data` units or indices. Defaults to None.</span>
<span class="sd">        roi (tuple, optional): A single `(start, end)` tuple specifying the</span>
<span class="sd">            Region of Interest where baseline fitting should *occur*. Data outside</span>
<span class="sd">            this ROI (and within `exclude_regions`) will not be used. If None,</span>
<span class="sd">            the entire dataset (minus `exclude_regions`) is used.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - **y_corrected** (np.ndarray): The baseline-corrected `y_data`.</span>
<span class="sd">            - **baseline** (np.ndarray): The calculated polynomial baseline.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If inputs are invalid (e.g., `y_data` not 1D, mismatched</span>
<span class="sd">            lengths, or invalid `poly_order`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">y_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y_data must be a 1D NumPy array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">poly_order</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;poly_order must be a non-negative integer.&quot;</span><span class="p">)</span>

    <span class="n">n_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_data</span><span class="p">)</span>

    <span class="c1"># Determine the reference axis for fitting and evaluation</span>
    <span class="k">if</span> <span class="n">x_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_data must be a 1D NumPy array if provided.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_points</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_data and y_data must have the same length.&quot;</span><span class="p">)</span>
        <span class="n">reference_axis</span> <span class="o">=</span> <span class="n">x_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reference_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_points</span><span class="p">)</span>

    <span class="c1"># Validate region formats</span>
    <span class="k">if</span> <span class="n">roi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;roi must be a tuple of (start, end).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exclude_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exclude_regions must be a list of (start, end) tuples.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Each item in exclude_regions (item </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">) must be a (start, end) tuple.&quot;</span>
                <span class="p">)</span>

    <span class="c1"># Create the mask for points to include in the fit</span>
    <span class="n">fit_mask</span> <span class="o">=</span> <span class="n">_create_fit_mask</span><span class="p">(</span>
        <span class="n">reference_axis</span><span class="p">,</span> <span class="n">fit_window</span><span class="o">=</span><span class="n">roi</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude_regions</span>
    <span class="p">)</span>

    <span class="n">num_points_for_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fit_mask</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_points_for_fit</span> <span class="o">&lt;=</span> <span class="n">poly_order</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Not enough points (</span><span class="si">{</span><span class="n">num_points_for_fit</span><span class="si">}</span><span class="s2">) for polynomial fit of &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;order </span><span class="si">{</span><span class="n">poly_order</span><span class="si">}</span><span class="s2"> after applying ROI/exclusions. &quot;</span>
            <span class="s2">&quot;Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Fit polynomial using only the masked (True) points</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">reference_axis</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">],</span> <span class="n">poly_order</span><span class="p">)</span>
        <span class="c1"># Evaluate the polynomial over the entire original axis</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">reference_axis</span><span class="p">)</span>
        <span class="n">y_corrected</span> <span class="o">=</span> <span class="n">y_data</span> <span class="o">-</span> <span class="n">baseline</span>
        <span class="k">return</span> <span class="n">y_corrected</span><span class="p">,</span> <span class="n">baseline</span>
    <span class="k">except</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Polynomial baseline fit failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">)</span></div>



<div class="viewcode-block" id="baseline_constant_offset">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.baseline_constant_offset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">baseline_constant_offset</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">offset_region_indices</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs baseline correction by subtracting a constant offset.</span>

<span class="sd">    The offset is calculated from a specified region of `y_data` (using</span>
<span class="sd">    array indices) via its mean or median.</span>

<span class="sd">    Args:</span>
<span class="sd">        y_data (np.ndarray): The 1D spectral data array.</span>
<span class="sd">        offset_region_indices (tuple, optional): A `(start_index, end_index)`</span>
<span class="sd">            tuple specifying the slice of `y_data` (exclusive of `end_index`)</span>
<span class="sd">            to calculate the offset from. If None, the entire array is used.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        method (str, optional): The method to calculate the offset. Can be</span>
<span class="sd">            &#39;mean&#39; or &#39;median&#39;. Defaults to &#39;mean&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - **y_corrected** (np.ndarray): The baseline-corrected `y_data`.</span>
<span class="sd">            - **baseline** (np.ndarray): The calculated constant baseline array.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If inputs are invalid (e.g., `y_data` not 1D, invalid `method`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">y_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y_data must be a 1D NumPy array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span> <span class="s2">&quot;median&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Method must be &#39;mean&#39; or &#39;median&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Determine the slice of data to use for offset calculation</span>
    <span class="k">if</span> <span class="n">offset_region_indices</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset_region_indices</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset_region_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;offset_region_indices must be a (start_index, end_index) tuple.&quot;</span>
            <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">offset_region_indices</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;offset_region_indices components must be convertible to int.&quot;</span>
            <span class="p">)</span>

        <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">)</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="n">end_idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start_idx</span> <span class="o">&gt;=</span> <span class="n">end_idx</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid offset_region_indices (</span><span class="si">{</span><span class="n">offset_region_indices</span><span class="si">}</span><span class="s2">). &quot;</span>
                <span class="s2">&quot;Start index must be less than end index. Using whole array.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">region_for_offset</span> <span class="o">=</span> <span class="n">y_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">region_for_offset</span> <span class="o">=</span> <span class="n">y_data</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;offset_region_indices not provided. Using whole array for offset.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">region_for_offset</span> <span class="o">=</span> <span class="n">y_data</span>

    <span class="k">if</span> <span class="n">region_for_offset</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Offset calculation region is empty. Returning original data.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">)</span>

    <span class="c1"># Calculate the offset value</span>
    <span class="n">offset_value</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">region_for_offset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span>
        <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">region_for_offset</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">baseline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">offset_value</span><span class="p">)</span>
    <span class="n">y_corrected</span> <span class="o">=</span> <span class="n">y_data</span> <span class="o">-</span> <span class="n">offset_value</span>
    <span class="k">return</span> <span class="n">y_corrected</span><span class="p">,</span> <span class="n">baseline</span></div>



<span class="c1"># --- Model Functions for Curve Fitting ---</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_stretched_exponential_decay_model</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Model: y0 + amplitude * exp(-(t / tau)**beta).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tau</span> <span class="o">&lt;=</span> <span class="mf">1e-12</span><span class="p">:</span>  <span class="c1"># Prevent division by zero or extremely small tau</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mf">1e-3</span> <span class="o">&lt;</span> <span class="n">beta</span> <span class="o">&lt;=</span> <span class="mf">1.0001</span><span class="p">):</span>  <span class="c1"># Beta is typically 0 &lt; beta &lt;= 1</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">decay_arg</span> <span class="o">=</span> <span class="n">t</span> <span class="o">/</span> <span class="n">tau</span>
    <span class="c1"># Ensure argument to exponentiation is non-negative</span>
    <span class="n">decay_arg_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">decay_arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">decay_arg_safe</span><span class="p">)</span> <span class="o">**</span> <span class="n">beta</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_mono_exponential_decay_model</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">tau</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Model: y0 + amplitude * exp(-t / tau).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tau</span> <span class="o">&lt;=</span> <span class="mf">1e-12</span><span class="p">:</span>  <span class="c1"># Prevent division by zero or extremely small tau</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">return</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span> <span class="o">/</span> <span class="n">tau</span><span class="p">)</span>


<span class="c1"># --- Exponential Baseline Core Logic ---</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_fit_exponential_baseline</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">model_func</span><span class="p">,</span>
    <span class="n">param_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
    <span class="n">default_initial_guess_generator</span><span class="p">,</span>
    <span class="n">default_bounds</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
    <span class="n">user_initial_guess</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">user_bounds</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fit_region</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A generic helper to fit an exponential-like baseline model.</span>

<span class="sd">    This function abstracts the common logic for fitting an exponential model using</span>
<span class="sd">    `scipy.optimize.curve_fit`, including handling of initial guesses, bounds,</span>
<span class="sd">    and fit regions.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray, dict]: Corrected data, baseline, and parameters.</span>
<span class="sd">            Returns original data, zero baseline, and None if fit fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">y_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y_data must be a 1D NumPy array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> requires x_data as a 1D NumPy array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_data and y_data must have the same length.&quot;</span><span class="p">)</span>

    <span class="c1"># Validate region formats</span>
    <span class="k">if</span> <span class="n">fit_region</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">fit_region</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">fit_region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fit_region must be a (start_x, end_x) tuple.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exclude_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;exclude_regions must be a list of (start_x, end_x) tuples.&quot;</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Each item in exclude_regions (item </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">) must be a (start_x, end_x) tuple.&quot;</span>
                <span class="p">)</span>

    <span class="n">fit_mask</span> <span class="o">=</span> <span class="n">_create_fit_mask</span><span class="p">(</span>
        <span class="n">x_data</span><span class="p">,</span> <span class="n">fit_window</span><span class="o">=</span><span class="n">fit_region</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude_regions</span>
    <span class="p">)</span>
    <span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span> <span class="o">=</span> <span class="n">x_data</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">],</span> <span class="n">y_data</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_masked</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n_params</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Not enough points (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">x_masked</span><span class="p">)</span><span class="si">}</span><span class="s2">) to fit </span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">n_params</span><span class="si">}</span><span class="s2"> parameters after applying regions. &quot;</span>
            <span class="s2">&quot;Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="kc">None</span>

    <span class="c1"># Handle initial guess</span>
    <span class="k">if</span> <span class="n">user_initial_guess</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">current_initial_guess</span> <span class="o">=</span> <span class="n">default_initial_guess_generator</span><span class="p">(</span><span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span><span class="p">)</span>
        <span class="n">param_order_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Using heuristic initial guess for </span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;([</span><span class="si">{</span><span class="n">param_order_str</span><span class="si">}</span><span class="s2">]): </span><span class="si">{</span><span class="n">current_initial_guess</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_initial_guess</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_initial_guess</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_params</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;initial_guess must be a list/array of </span><span class="si">{</span><span class="n">n_params</span><span class="si">}</span><span class="s2"> values.&quot;</span>
            <span class="p">)</span>
        <span class="n">current_initial_guess</span> <span class="o">=</span> <span class="n">user_initial_guess</span>

    <span class="c1"># Handle parameter bounds</span>
    <span class="n">current_bounds</span> <span class="o">=</span> <span class="n">default_bounds</span>
    <span class="k">if</span> <span class="n">user_bounds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_bounds</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">n_params</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">n_params</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;bounds must be a tuple of two lists/arrays of length </span><span class="si">{</span><span class="n">n_params</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="s2">&quot;([lowers], [uppers])&quot;</span>
            <span class="p">)</span>
        <span class="n">current_bounds</span> <span class="o">=</span> <span class="n">user_bounds</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
            <span class="n">model_func</span><span class="p">,</span>
            <span class="n">x_masked</span><span class="p">,</span>
            <span class="n">y_masked</span><span class="p">,</span>
            <span class="n">p0</span><span class="o">=</span><span class="n">current_initial_guess</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">current_bounds</span><span class="p">,</span>
            <span class="n">maxfev</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;trf&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">baseline</span> <span class="o">=</span> <span class="n">model_func</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>
        <span class="n">y_corrected</span> <span class="o">=</span> <span class="n">y_data</span> <span class="o">-</span> <span class="n">baseline</span>

        <span class="c1"># Calculate parameter standard errors from covariance matrix</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">pcov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">perr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">perr</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_params</span>
            <span class="k">if</span> <span class="n">pcov</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Covariance matrix from fit is problematic. Std errors set to NaN.&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Compile results into a dictionary</span>
        <span class="n">fit_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="n">param_names</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span> <span class="n">popt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_params</span><span class="p">)}</span>
        <span class="n">fit_parameters</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;std_</span><span class="si">{</span><span class="n">param_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">perr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_params</span><span class="p">)}</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">y_corrected</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">fit_parameters</span>

    <span class="k">except</span> <span class="ne">RuntimeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fit did not converge: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;ValueError during </span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fit: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected error in </span><span class="si">{</span><span class="n">model_func</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> fit: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y_data</span><span class="p">),</span> <span class="kc">None</span>


<span class="c1"># --- Heuristic Initial Guess Generators for Exponential Models ---</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_heuristic_stretched_exp_guess</span><span class="p">(</span><span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a heuristic initial guess for a stretched exponential fit.&quot;&quot;&quot;</span>
    <span class="n">guess_y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
        <span class="n">y_masked</span><span class="p">[</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_masked</span><span class="p">)</span> <span class="o">//</span> <span class="mi">20</span><span class="p">)</span> <span class="p">:]</span>
    <span class="p">)</span>  <span class="c1"># Offset is mean of tail</span>
    <span class="n">guess_A</span> <span class="o">=</span> <span class="n">y_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">guess_y0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_masked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>  <span class="c1"># Amplitude</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_masked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x_masked</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">guess_tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_masked</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.0</span>  <span class="c1"># Decay time is ~1/3 of range</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">guess_tau</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">guess_beta</span> <span class="o">=</span> <span class="mf">0.8</span>  <span class="c1"># Common value for stretched exponential</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">guess_y0</span><span class="p">,</span> <span class="n">guess_A</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">guess_tau</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">),</span> <span class="n">guess_beta</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_heuristic_mono_exp_guess</span><span class="p">(</span><span class="n">x_masked</span><span class="p">,</span> <span class="n">y_masked</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a heuristic initial guess for a mono-exponential fit.&quot;&quot;&quot;</span>
    <span class="n">guess_y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y_masked</span><span class="p">[</span><span class="o">-</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_masked</span><span class="p">)</span> <span class="o">//</span> <span class="mi">20</span><span class="p">)</span> <span class="p">:])</span>
    <span class="n">guess_A</span> <span class="o">=</span> <span class="n">y_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">guess_y0</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_masked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_masked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x_masked</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">guess_tau</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_masked</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_masked</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">guess_tau</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">guess_y0</span><span class="p">,</span> <span class="n">guess_A</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">guess_tau</span><span class="p">,</span> <span class="mf">1e-9</span><span class="p">)]</span>


<span class="c1"># --- Public Exponential Baseline Functions ---</span>


<div class="viewcode-block" id="baseline_stretched_exponential">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.baseline_stretched_exponential">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">baseline_stretched_exponential</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">initial_guess</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fit_region</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fits and subtracts a stretched exponential decay baseline.</span>

<span class="sd">    The model fitted is: ``y(x) = y0 + A * exp(-((x / τ)**β))``</span>

<span class="sd">    Args:</span>
<span class="sd">        y_data (np.ndarray): The 1D spectral data array.</span>
<span class="sd">        x_data (np.ndarray): The x-axis data corresponding to y_data.</span>
<span class="sd">        initial_guess (list, optional): A list of initial guess values for the</span>
<span class="sd">            parameters `[y0, A, tau, beta]`. If None, a heuristic guess is</span>
<span class="sd">            generated. Defaults to None.</span>
<span class="sd">        bounds (tuple, optional): A tuple `([lowers], [uppers])` for parameter</span>
<span class="sd">            bounds, e.g., `([y0_low, ...], [y0_high, ...])`. Defaults to</span>
<span class="sd">            `([-inf, -inf, 1e-12, 1e-3], [inf, inf, inf, 1.0])`.</span>
<span class="sd">        fit_region (tuple, optional): A `(start, end)` tuple specifying the region</span>
<span class="sd">            in `x_data` units to use for fitting. Defaults to the whole range.</span>
<span class="sd">        exclude_regions (list of tuples, optional): A list of `(start, end)`</span>
<span class="sd">            tuples to *exclude* from the fit. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray, dict | None]:</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - **y_corrected** (np.ndarray): The baseline-corrected `y_data`.</span>
<span class="sd">            - **baseline** (np.ndarray): The calculated exponential baseline.</span>
<span class="sd">            - **fit_parameters** (dict | None): A dictionary with the fitted</span>
<span class="sd">              parameters (`y0`, `A`, `tau`, `beta`) and their standard errors</span>
<span class="sd">              (`std_y0`, etc.). Returns `None` if the fit fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;y0&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;tau&quot;</span><span class="p">,</span> <span class="s2">&quot;beta&quot;</span><span class="p">]</span>
    <span class="n">default_bounds</span> <span class="o">=</span> <span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">_fit_exponential_baseline</span><span class="p">(</span>
        <span class="n">y_data</span><span class="p">,</span>
        <span class="n">x_data</span><span class="p">,</span>
        <span class="n">_stretched_exponential_decay_model</span><span class="p">,</span>
        <span class="n">param_names</span><span class="p">,</span>
        <span class="n">_heuristic_stretched_exp_guess</span><span class="p">,</span>
        <span class="n">default_bounds</span><span class="p">,</span>
        <span class="n">user_initial_guess</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">,</span>
        <span class="n">user_bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">fit_region</span><span class="o">=</span><span class="n">fit_region</span><span class="p">,</span>
        <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude_regions</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="baseline_mono_exponential">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.baseline_mono_exponential">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">baseline_mono_exponential</span><span class="p">(</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">initial_guess</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fit_region</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fits and subtracts a mono-exponential decay baseline.</span>

<span class="sd">    The model fitted is: ``y(x) = y0 + A * exp(-(x / τ))``</span>

<span class="sd">    Args:</span>
<span class="sd">        y_data (np.ndarray): The 1D spectral data array.</span>
<span class="sd">        x_data (np.ndarray): The x-axis data corresponding to y_data.</span>
<span class="sd">        initial_guess (list, optional): A list of initial guess values for the</span>
<span class="sd">            parameters `[y0, A, tau]`. If None, a heuristic guess is generated.</span>
<span class="sd">            Defaults to None.</span>
<span class="sd">        bounds (tuple, optional): A tuple `([lowers], [uppers])` for parameter</span>
<span class="sd">            bounds. Defaults to `([-inf, -inf, 1e-12], [inf, inf, inf])`.</span>
<span class="sd">        fit_region (tuple, optional): A `(start, end)` tuple specifying the region</span>
<span class="sd">            in `x_data` units to use for fitting. Defaults to the whole range.</span>
<span class="sd">        exclude_regions (list of tuples, optional): A list of `(start, end)`</span>
<span class="sd">            tuples to *exclude* from the fit. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray, dict | None]:</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - **y_corrected** (np.ndarray): The baseline-corrected `y_data`.</span>
<span class="sd">            - **baseline** (np.ndarray): The calculated exponential baseline.</span>
<span class="sd">            - **fit_parameters** (dict | None): A dictionary with the fitted</span>
<span class="sd">              parameters (`y0`, `A`, `tau`) and their standard errors</span>
<span class="sd">              (`std_y0`, etc.). Returns `None` if the fit fails.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;y0&quot;</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;tau&quot;</span><span class="p">]</span>
    <span class="n">default_bounds</span> <span class="o">=</span> <span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">1e-12</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">_fit_exponential_baseline</span><span class="p">(</span>
        <span class="n">y_data</span><span class="p">,</span>
        <span class="n">x_data</span><span class="p">,</span>
        <span class="n">_mono_exponential_decay_model</span><span class="p">,</span>
        <span class="n">param_names</span><span class="p">,</span>
        <span class="n">_heuristic_mono_exp_guess</span><span class="p">,</span>
        <span class="n">default_bounds</span><span class="p">,</span>
        <span class="n">user_initial_guess</span><span class="o">=</span><span class="n">initial_guess</span><span class="p">,</span>
        <span class="n">user_bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">fit_region</span><span class="o">=</span><span class="n">fit_region</span><span class="p">,</span>
        <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude_regions</span><span class="p">,</span>
    <span class="p">)</span></div>



<span class="c1"># --- 2D Baseline Correction Helpers ---</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_polynomial_features_2d</span><span class="p">(</span>
    <span class="n">x_coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">order_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">order_y</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a 2D polynomial design matrix (Vandermonde-like).</span>

<span class="sd">    For each pair `(x, y)` in the input coordinates, this function creates a row</span>
<span class="sd">    containing all polynomial terms `x^i * y^j` where `0&lt;=i&lt;=order_x` and</span>
<span class="sd">    `0&lt;=j&lt;=order_y`. The ordering is row-major on `j`, then `i`, i.e.,</span>
<span class="sd">    `[1, y, y^2, ..., x, xy, xy^2, ..., x^2, x^2y, ...]`.</span>

<span class="sd">    Args:</span>
<span class="sd">        x_coords (np.ndarray): 1D array of x-coordinates.</span>
<span class="sd">        y_coords (np.ndarray): 1D array of y-coordinates of the same length.</span>
<span class="sd">        order_x (int): Maximum polynomial order for the x-dimension.</span>
<span class="sd">        order_y (int): Maximum polynomial order for the y-dimension.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray:</span>
<span class="sd">            The design matrix where each row corresponds to an `(x,y)` pair and</span>
<span class="sd">            columns are the polynomial feature terms.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x_coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">y_coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_coords</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_coords</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_coords and y_coords must be 1D arrays of the same length.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">order_x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">order_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Polynomial orders must be non-negative.&quot;</span><span class="p">)</span>

    <span class="n">num_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_coords</span><span class="p">)</span>
    <span class="n">num_coeffs</span> <span class="o">=</span> <span class="p">(</span><span class="n">order_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">design_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_points</span><span class="p">,</span> <span class="n">num_coeffs</span><span class="p">))</span>

    <span class="n">col_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">design_matrix</span><span class="p">[:,</span> <span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_coords</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_coords</span><span class="o">**</span><span class="n">j</span><span class="p">)</span>
            <span class="n">col_idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">design_matrix</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_evaluate_polynomial_surface</span><span class="p">(</span>
    <span class="n">x_mesh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">y_mesh</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">coeffs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">order_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">order_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluates a 2D polynomial surface on a coordinate grid.</span>

<span class="sd">    Args:</span>
<span class="sd">        x_mesh (np.ndarray): 2D mesh of x-coordinates (e.g., from `np.meshgrid`).</span>
<span class="sd">        y_mesh (np.ndarray): 2D mesh of y-coordinates.</span>
<span class="sd">        coeffs (np.ndarray): 1D array of polynomial coefficients, ordered as</span>
<span class="sd">                             generated by `_polynomial_features_2d`.</span>
<span class="sd">        order_x (int): Maximum order for x used to generate `coeffs`.</span>
<span class="sd">        order_y (int): Maximum order for y used to generate `coeffs`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: The evaluated 2D polynomial surface with the same shape</span>
<span class="sd">                    as `x_mesh` and `y_mesh`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x_mesh</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">y_mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x_mesh and y_mesh must have the same shape.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;coeffs must be a 1D array.&quot;</span><span class="p">)</span>

    <span class="n">expected_num_coeffs</span> <span class="o">=</span> <span class="p">(</span><span class="n">order_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">!=</span> <span class="n">expected_num_coeffs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Number of coefficients (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;expected for orders (</span><span class="si">{</span><span class="n">order_x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">order_y</span><span class="si">}</span><span class="s2">), which is </span><span class="si">{</span><span class="n">expected_num_coeffs</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="n">surface</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x_mesh</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">coeff_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">order_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">surface</span> <span class="o">+=</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">coeff_idx</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_mesh</span><span class="o">**</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_mesh</span><span class="o">**</span><span class="n">j</span><span class="p">)</span>
            <span class="n">coeff_idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">surface</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_slice_from_region</span><span class="p">(</span>
    <span class="n">axis_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">start_val</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">end_val</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">slice</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts a value range in `axis_data` units to an index slice.</span>

<span class="sd">    Args:</span>
<span class="sd">        axis_data (np.ndarray): A sorted 1D array of axis coordinates.</span>
<span class="sd">        start_val (float): The starting value of the region.</span>
<span class="sd">        end_val (float): The ending value of the region.</span>

<span class="sd">    Returns:</span>
<span class="sd">        slice: An index slice `slice(start_index, end_index)` corresponding</span>
<span class="sd">               to the value range.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">start_val</span> <span class="o">&gt;</span> <span class="n">end_val</span><span class="p">:</span>  <span class="c1"># Allow reversed specification for convenience</span>
        <span class="n">start_val</span><span class="p">,</span> <span class="n">end_val</span> <span class="o">=</span> <span class="n">end_val</span><span class="p">,</span> <span class="n">start_val</span>

    <span class="n">idx_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">axis_data</span><span class="p">,</span> <span class="n">start_val</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
    <span class="n">idx_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">axis_data</span><span class="p">,</span> <span class="n">end_val</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>

    <span class="c1"># Clip to ensure indices are within array bounds for slicing</span>
    <span class="n">idx_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx_start</span><span class="p">)</span>
    <span class="n">idx_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axis_data</span><span class="p">),</span> <span class="n">idx_end</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">idx_start</span><span class="p">,</span> <span class="n">idx_end</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_create_fit_mask_2d</span><span class="p">(</span>
    <span class="n">shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">x_axis_coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">y_axis_coords</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fit_window_roi</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates a 2D boolean mask for fitting based on ROI and exclusions.</span>

<span class="sd">    Args:</span>
<span class="sd">        shape (tuple[int, int]): The (rows, cols) shape of the 2D data.</span>
<span class="sd">        x_axis_coords (np.ndarray, optional): 1D array of x-coordinates for</span>
<span class="sd">            all columns. If None, column indices are used.</span>
<span class="sd">        y_axis_coords (np.ndarray, optional): 1D array of y-coordinates for</span>
<span class="sd">            all rows. If None, row indices are used.</span>
<span class="sd">        fit_window_roi (tuple, optional): A region `((x_start, x_end), (y_start, y_end))`</span>
<span class="sd">            where fitting *should* occur. If None, the entire area is considered.</span>
<span class="sd">        exclude_regions (list, optional): List of regions `[((x1s,x1e),(y1s,y1e)), ...]`</span>
<span class="sd">            to *exclude* from fitting.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A 2D boolean mask of the given shape. `True` where fitting</span>
<span class="sd">                    should occur.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">shape</span>
    <span class="n">_x_axis</span> <span class="o">=</span> <span class="n">x_axis_coords</span> <span class="k">if</span> <span class="n">x_axis_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">_y_axis</span> <span class="o">=</span> <span class="n">y_axis_coords</span> <span class="k">if</span> <span class="n">y_axis_coords</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

    <span class="c1"># Initialize mask based on the fit window (ROI)</span>
    <span class="k">if</span> <span class="n">fit_window_roi</span><span class="p">:</span>
        <span class="p">(</span><span class="n">x_roi_start</span><span class="p">,</span> <span class="n">x_roi_end</span><span class="p">),</span> <span class="p">(</span><span class="n">y_roi_start</span><span class="p">,</span> <span class="n">y_roi_end</span><span class="p">)</span> <span class="o">=</span> <span class="n">fit_window_roi</span>
        <span class="n">x_slice_roi</span> <span class="o">=</span> <span class="n">_get_slice_from_region</span><span class="p">(</span><span class="n">_x_axis</span><span class="p">,</span> <span class="n">x_roi_start</span><span class="p">,</span> <span class="n">x_roi_end</span><span class="p">)</span>
        <span class="n">y_slice_roi</span> <span class="o">=</span> <span class="n">_get_slice_from_region</span><span class="p">(</span><span class="n">_y_axis</span><span class="p">,</span> <span class="n">y_roi_start</span><span class="p">,</span> <span class="n">y_roi_end</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">y_slice_roi</span><span class="p">,</span> <span class="n">x_slice_roi</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># Set excluded regions in the mask to False</span>
    <span class="k">if</span> <span class="n">exclude_regions</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">exclude_regions</span><span class="p">:</span>
            <span class="p">(</span><span class="n">x_excl_start</span><span class="p">,</span> <span class="n">x_excl_end</span><span class="p">),</span> <span class="p">(</span><span class="n">y_excl_start</span><span class="p">,</span> <span class="n">y_excl_end</span><span class="p">)</span> <span class="o">=</span> <span class="n">region</span>
            <span class="n">x_slice_excl</span> <span class="o">=</span> <span class="n">_get_slice_from_region</span><span class="p">(</span><span class="n">_x_axis</span><span class="p">,</span> <span class="n">x_excl_start</span><span class="p">,</span> <span class="n">x_excl_end</span><span class="p">)</span>
            <span class="n">y_slice_excl</span> <span class="o">=</span> <span class="n">_get_slice_from_region</span><span class="p">(</span><span class="n">_y_axis</span><span class="p">,</span> <span class="n">y_excl_start</span><span class="p">,</span> <span class="n">y_excl_end</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">y_slice_excl</span><span class="p">,</span> <span class="n">x_slice_excl</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">mask</span>


<span class="c1"># --- 2D Baseline Correction Function ---</span>


<div class="viewcode-block" id="baseline_polynomial_2d">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.baseline_polynomial_2d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">baseline_polynomial_2d</span><span class="p">(</span>
    <span class="n">z_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">x_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">y_data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">poly_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">exclude_regions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">roi</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Performs 2D baseline correction by subtracting a fitted polynomial surface.</span>

<span class="sd">    The polynomial surface is fitted to regions of the data presumed to be baseline.</span>
<span class="sd">    These regions are defined by an overall region of interest (ROI) and/or by</span>
<span class="sd">    excluding specific rectangular signal regions.</span>

<span class="sd">    Args:</span>
<span class="sd">        z_data (np.ndarray): The 2D data array (e.g., image, spectral map).</span>
<span class="sd">        x_data (np.ndarray, optional): 1D array of x-axis coordinates</span>
<span class="sd">            corresponding to the columns of `z_data`. If None, column indices are used.</span>
<span class="sd">        y_data (np.ndarray, optional): 1D array of y-axis coordinates</span>
<span class="sd">            corresponding to the rows of `z_data`. If None, row indices are used.</span>
<span class="sd">        poly_order (int or tuple[int, int], optional): Order of the polynomial.</span>
<span class="sd">            If an int, it&#39;s used for both x and y orders: `(order, order)`.</span>
<span class="sd">            If a tuple `(order_x, order_y)`, it specifies the maximum order for</span>
<span class="sd">            x and y terms, respectively. Defaults to (1, 1) (a tilted plane).</span>
<span class="sd">        exclude_regions (list of tuples, optional): List of rectangular regions</span>
<span class="sd">            to *exclude* from baseline fitting. Each region is defined as</span>
<span class="sd">            `((x_start, x_end), (y_start, y_end))`. Interpreted in `x_data`/`y_data`</span>
<span class="sd">            units or indices. Defaults to None.</span>
<span class="sd">        roi (tuple, optional): A single rectangular region `((x_start, x_end), (y_start, y_end))`</span>
<span class="sd">            specifying where baseline fitting should *occur*. Data outside this</span>
<span class="sd">            ROI is not used. Interpreted in `x_data`/`y_data` units or indices.</span>
<span class="sd">            If None, the entire dataset (minus `exclude_regions`) is used.</span>
<span class="sd">            Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple[np.ndarray, np.ndarray]:</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - **z_corrected** (np.ndarray): The baseline-corrected 2D data.</span>
<span class="sd">            - **baseline_surface** (np.ndarray): The calculated 2D polynomial baseline.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If inputs are invalid (e.g., `z_data` not 2D, mismatched</span>
<span class="sd">            axis lengths, invalid `poly_order` or region formats).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="n">z_data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;z_data must be a 2D NumPy array.&quot;</span><span class="p">)</span>

    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">z_data</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Parse polynomial order</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poly_order</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">order_x</span><span class="p">,</span> <span class="n">order_y</span> <span class="o">=</span> <span class="n">poly_order</span><span class="p">,</span> <span class="n">poly_order</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">poly_order</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly_order</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">order_x</span><span class="p">,</span> <span class="n">order_y</span> <span class="o">=</span> <span class="n">poly_order</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">order_x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order_y</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">order_x</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="n">order_y</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;poly_order tuple elements must be non-negative integers.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;poly_order must be an int or a tuple of two ints.&quot;</span><span class="p">)</span>

    <span class="c1"># Prepare coordinate axes for fitting and evaluation</span>
    <span class="n">x_coords_eval</span> <span class="o">=</span> <span class="n">x_data</span> <span class="k">if</span> <span class="n">x_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">y_coords_eval</span> <span class="o">=</span> <span class="n">y_data</span> <span class="k">if</span> <span class="n">y_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_coords_eval</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cols</span> <span class="ow">or</span> <span class="n">x_coords_eval</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x_data must be a 1D array of length </span><span class="si">{</span><span class="n">cols</span><span class="si">}</span><span class="s2"> (num columns).&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_coords_eval</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rows</span> <span class="ow">or</span> <span class="n">y_coords_eval</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;y_data must be a 1D array of length </span><span class="si">{</span><span class="n">rows</span><span class="si">}</span><span class="s2"> (num rows).&quot;</span><span class="p">)</span>

    <span class="c1"># Validate region formats</span>
    <span class="n">region_format_error</span> <span class="o">=</span> <span class="s2">&quot;must be a tuple of ((x_start, x_end), (y_start, y_end)).&quot;</span>
    <span class="k">if</span> <span class="n">roi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">roi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">roi</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;roi </span><span class="si">{</span><span class="n">region_format_error</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">exclude_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;exclude_regions must be a list of region tuples.&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">exclude_regions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Each item in exclude_regions (item </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">region_format_error</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

    <span class="c1"># Create coordinate meshgrid for full surface evaluation</span>
    <span class="n">XX_eval</span><span class="p">,</span> <span class="n">YY_eval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x_coords_eval</span><span class="p">,</span> <span class="n">y_coords_eval</span><span class="p">)</span>

    <span class="c1"># Create the 2D mask indicating which points to use for fitting</span>
    <span class="n">fit_mask</span> <span class="o">=</span> <span class="n">_create_fit_mask_2d</span><span class="p">(</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">z_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">x_axis_coords</span><span class="o">=</span><span class="n">x_coords_eval</span><span class="p">,</span>
        <span class="n">y_axis_coords</span><span class="o">=</span><span class="n">y_coords_eval</span><span class="p">,</span>
        <span class="n">fit_window_roi</span><span class="o">=</span><span class="n">roi</span><span class="p">,</span>
        <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude_regions</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Select the points for fitting based on the mask (flattened to 1D)</span>
    <span class="n">x_points_to_fit</span> <span class="o">=</span> <span class="n">XX_eval</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">]</span>
    <span class="n">y_points_to_fit</span> <span class="o">=</span> <span class="n">YY_eval</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">]</span>
    <span class="n">z_values_to_fit</span> <span class="o">=</span> <span class="n">z_data</span><span class="p">[</span><span class="n">fit_mask</span><span class="p">]</span>

    <span class="n">num_points_for_fit</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_values_to_fit</span><span class="p">)</span>
    <span class="n">num_coeffs_needed</span> <span class="o">=</span> <span class="p">(</span><span class="n">order_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">order_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_points_for_fit</span> <span class="o">&lt;</span> <span class="n">num_coeffs_needed</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Not enough points (</span><span class="si">{</span><span class="n">num_points_for_fit</span><span class="si">}</span><span class="s2">) for polynomial fit with &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;orders (</span><span class="si">{</span><span class="n">order_x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">order_y</span><span class="si">}</span><span class="s2">), which requires </span><span class="si">{</span><span class="n">num_coeffs_needed</span><span class="si">}</span><span class="s2"> coefficients. &quot;</span>
            <span class="s2">&quot;Returning original data.&quot;</span><span class="p">,</span>
            <span class="ne">UserWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">z_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z_data</span><span class="p">)</span>

    <span class="c1"># Construct the design matrix and perform the least-squares fit</span>
    <span class="n">design_matrix</span> <span class="o">=</span> <span class="n">_polynomial_features_2d</span><span class="p">(</span>
        <span class="n">x_points_to_fit</span><span class="p">,</span> <span class="n">y_points_to_fit</span><span class="p">,</span> <span class="n">order_x</span><span class="p">,</span> <span class="n">order_y</span>
    <span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">coeffs</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">design_matrix</span><span class="p">,</span> <span class="n">z_values_to_fit</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">rank</span> <span class="o">&lt;</span> <span class="n">num_coeffs_needed</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Polynomial fit may be poorly conditioned. Rank deficiency detected: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;rank=</span><span class="si">{</span><span class="n">rank</span><span class="si">}</span><span class="s2">, expected_coeffs=</span><span class="si">{</span><span class="n">num_coeffs_needed</span><span class="si">}</span><span class="s2">. Results might be unreliable.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Evaluate the fitted surface over the entire grid and subtract</span>
        <span class="n">baseline_surface</span> <span class="o">=</span> <span class="n">_evaluate_polynomial_surface</span><span class="p">(</span>
            <span class="n">XX_eval</span><span class="p">,</span> <span class="n">YY_eval</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">order_x</span><span class="p">,</span> <span class="n">order_y</span>
        <span class="p">)</span>
        <span class="n">z_corrected</span> <span class="o">=</span> <span class="n">z_data</span> <span class="o">-</span> <span class="n">baseline_surface</span>
        <span class="k">return</span> <span class="n">z_corrected</span><span class="p">,</span> <span class="n">baseline_surface</span>

    <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Polynomial surface fit failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Returning original data.&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">z_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">z_data</span><span class="p">)</span></div>



<span class="c1"># --- Example Usage and Demonstrations ---</span>


<div class="viewcode-block" id="generate_gaussian">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.generate_gaussian">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates a Gaussian peak for example data.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">amplitude</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span></div>



<div class="viewcode-block" id="plot_correction">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.plot_correction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">plot_correction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_original</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">y_corrected</span><span class="p">,</span> <span class="n">title</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper function for plotting 1D correction results.&quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_original</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Original Data&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Calculated Baseline&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y_corrected</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Corrected Data&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X-axis&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Y-axis&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>



<div class="viewcode-block" id="run_examples">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.run_examples">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">run_examples</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Runs and plots a series of example demonstrations for the baseline</span>
<span class="sd">    correction functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- Running Baseline Correction Examples ---&quot;</span><span class="p">)</span>

    <span class="c1"># --- Common data parameters ---</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">signal1</span> <span class="o">=</span> <span class="n">generate_gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">signal2</span> <span class="o">=</span> <span class="n">generate_gaussian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="n">pure_signal</span> <span class="o">=</span> <span class="n">signal1</span> <span class="o">+</span> <span class="n">signal2</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># --- 1. Polynomial Baseline Example ---</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">1. Polynomial Baseline Example&quot;</span><span class="p">)</span>
    <span class="n">poly_baseline_true</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">y_poly</span> <span class="o">=</span> <span class="n">poly_baseline_true</span> <span class="o">+</span> <span class="n">pure_signal</span> <span class="o">+</span> <span class="n">noise</span>

    <span class="n">y_corrected_poly</span><span class="p">,</span> <span class="n">baseline_poly</span> <span class="o">=</span> <span class="n">baseline_polynomial</span><span class="p">(</span>
        <span class="n">y_poly</span><span class="p">,</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">poly_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">exclude_regions</span><span class="o">=</span><span class="p">[(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">80</span><span class="p">)],</span>  <span class="c1"># Exclude signal peaks</span>
    <span class="p">)</span>
    <span class="n">plot_correction</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y_poly</span><span class="p">,</span>
        <span class="n">baseline_poly</span><span class="p">,</span>
        <span class="n">y_corrected_poly</span><span class="p">,</span>
        <span class="s2">&quot;Polynomial Baseline Correction (Order 2)&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># --- 2. Constant Offset Baseline Example ---</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">2. Constant Offset Baseline Example&quot;</span><span class="p">)</span>
    <span class="n">constant_offset_true</span> <span class="o">=</span> <span class="mf">5.0</span>
    <span class="n">y_const</span> <span class="o">=</span> <span class="n">constant_offset_true</span> <span class="o">+</span> <span class="n">pure_signal</span> <span class="o">+</span> <span class="n">noise</span>

    <span class="n">y_corrected_const</span><span class="p">,</span> <span class="n">baseline_const</span> <span class="o">=</span> <span class="n">baseline_constant_offset</span><span class="p">(</span>
        <span class="n">y_const</span><span class="p">,</span> <span class="n">offset_region_indices</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span>  <span class="c1"># Use first 50 points</span>
    <span class="p">)</span>
    <span class="n">plot_correction</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y_const</span><span class="p">,</span>
        <span class="n">baseline_const</span><span class="p">,</span>
        <span class="n">y_corrected_const</span><span class="p">,</span>
        <span class="s2">&quot;Constant Offset Baseline Correction&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># --- 3. Mono-Exponential Baseline Example ---</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">3. Mono-Exponential Baseline Example&quot;</span><span class="p">)</span>
    <span class="n">mono_exp_baseline_true</span> <span class="o">=</span> <span class="n">_mono_exponential_decay_model</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">25.0</span>
    <span class="p">)</span>
    <span class="n">y_mono_exp</span> <span class="o">=</span> <span class="n">mono_exp_baseline_true</span> <span class="o">+</span> <span class="n">pure_signal</span> <span class="o">+</span> <span class="n">noise</span>

    <span class="c1"># Here we use the automatic heuristic guess</span>
    <span class="n">y_corrected_mono</span><span class="p">,</span> <span class="n">baseline_mono</span><span class="p">,</span> <span class="n">params_mono</span> <span class="o">=</span> <span class="n">baseline_mono_exponential</span><span class="p">(</span>
        <span class="n">y_mono_exp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="p">[(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">80</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">params_mono</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitted Mono-Exponential Params: </span><span class="si">{</span><span class="n">params_mono</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">plot_correction</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y_mono_exp</span><span class="p">,</span>
        <span class="n">baseline_mono</span><span class="p">,</span>
        <span class="n">y_corrected_mono</span><span class="p">,</span>
        <span class="s2">&quot;Mono-Exponential Baseline Correction (Heuristic Guess)&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># --- 4. Stretched Exponential Baseline Example ---</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">4. Stretched Exponential Baseline Example&quot;</span><span class="p">)</span>
    <span class="n">s_exp_baseline_true</span> <span class="o">=</span> <span class="n">_stretched_exponential_decay_model</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mf">25.0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mf">30.0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.7</span>
    <span class="p">)</span>
    <span class="n">y_s_exp</span> <span class="o">=</span> <span class="n">s_exp_baseline_true</span> <span class="o">+</span> <span class="n">pure_signal</span> <span class="o">+</span> <span class="n">noise</span>

    <span class="c1"># Provide an explicit initial guess</span>
    <span class="n">initial_guess_s</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">35.0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]</span>  <span class="c1"># y0, A, tau, beta</span>
    <span class="n">y_corrected_s</span><span class="p">,</span> <span class="n">baseline_s</span><span class="p">,</span> <span class="n">params_s</span> <span class="o">=</span> <span class="n">baseline_stretched_exponential</span><span class="p">(</span>
        <span class="n">y_s_exp</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">initial_guess</span><span class="o">=</span><span class="n">initial_guess_s</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="p">[(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">35</span><span class="p">),</span> <span class="p">(</span><span class="mi">65</span><span class="p">,</span> <span class="mi">75</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">params_s</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fitted Stretched Exponential Params: </span><span class="si">{</span><span class="n">params_s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">plot_correction</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">y_s_exp</span><span class="p">,</span>
        <span class="n">baseline_s</span><span class="p">,</span>
        <span class="n">y_corrected_s</span><span class="p">,</span>
        <span class="s2">&quot;Stretched Exponential Baseline Correction (Manual Guess)&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Examples Finished ---&quot;</span><span class="p">)</span></div>



<span class="c1"># --- Unit Tests ---</span>


<div class="viewcode-block" id="TestBaselineCorrection">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">TestBaselineCorrection</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">TestCase</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A unittest.TestCase class for testing the baseline correction functions.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="TestBaselineCorrection.setUp">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.setUp">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">setUp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up common data structures for use in all tests.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaussian</span> <span class="o">=</span> <span class="n">generate_gaussian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_linear</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_polynomial_zeroth_order">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_polynomial_zeroth_order">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_polynomial_zeroth_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test polynomial correction with order 0 (constant offset).&quot;&quot;&quot;</span>
        <span class="n">y_signal_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian</span> <span class="o">+</span> <span class="mf">5.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span>
        <span class="n">corrected</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_polynomial</span><span class="p">(</span>
            <span class="n">y_signal_offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">poly_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">baseline</span><span class="p">),</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">corrected</span><span class="p">,</span> <span class="n">y_signal_offset</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">baseline</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_polynomial_linear">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_polynomial_linear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_polynomial_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test polynomial correction with order 1 (linear).&quot;&quot;&quot;</span>
        <span class="n">y_signal_linear</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span>
        <span class="n">true_baseline_points</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span>

        <span class="n">corrected</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_polynomial</span><span class="p">(</span>
            <span class="n">y_signal_linear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">poly_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">true_baseline_points</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_allclose</span><span class="p">(</span><span class="n">corrected</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_polynomial_no_xdata">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_polynomial_no_xdata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_polynomial_no_xdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test polynomial correction when no x_data is provided (using indices).&quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y_idx_linear</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">0.1</span> <span class="o">*</span> <span class="n">indices</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">generate_gaussian</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span>
        <span class="p">)</span>

        <span class="n">corrected</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_polynomial</span><span class="p">(</span>
            <span class="n">y_idx_linear</span><span class="p">,</span> <span class="n">poly_order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="p">[(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">60</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span>
            <span class="n">y_idx_linear</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">corrected</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;Corrected data shape mismatch&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertGreater</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">baseline</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Baseline should not be flat&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_polynomial_insufficient_points">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_polynomial_insufficient_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_polynomial_insufficient_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test polynomial fit behavior with too few points.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
            <span class="n">corrected</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_polynomial</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y_linear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">poly_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">roi</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="s2">&quot;Not enough points&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">warn</span><span class="o">.</span><span class="n">message</span><span class="p">)</span> <span class="k">for</span> <span class="n">warn</span> <span class="ow">in</span> <span class="n">w</span><span class="p">))</span>
            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">corrected</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_linear</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_linear</span><span class="p">))</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_constant_offset_mean">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_constant_offset_mean">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_constant_offset_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test constant offset correction using the mean.&quot;&quot;&quot;</span>
        <span class="n">y_const_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian</span> <span class="o">+</span> <span class="mf">10.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span>
        <span class="n">offset_region</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">true_offset_in_region</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
            <span class="p">(</span><span class="mf">10.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">)[</span><span class="n">offset_region</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">offset_region</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="n">corrected</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_constant_offset</span><span class="p">(</span>
            <span class="n">y_const_signal</span><span class="p">,</span> <span class="n">offset_region_indices</span><span class="o">=</span><span class="n">offset_region</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">baseline</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">true_offset_in_region</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_constant_offset_median">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_constant_offset_median">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_constant_offset_median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test constant offset correction using the median.&quot;&quot;&quot;</span>
        <span class="n">y_const_signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian</span> <span class="o">+</span> <span class="mf">7.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span>
        <span class="n">offset_region</span> <span class="o">=</span> <span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">true_offset_in_region_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span>
            <span class="p">(</span><span class="mf">7.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span><span class="p">)[</span><span class="n">offset_region</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">offset_region</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="n">corrected</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_constant_offset</span><span class="p">(</span>
            <span class="n">y_const_signal</span><span class="p">,</span> <span class="n">offset_region_indices</span><span class="o">=</span><span class="n">offset_region</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;median&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">baseline</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">true_offset_in_region_median</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_constant_offset_invalid_region">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_constant_offset_invalid_region">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_constant_offset_invalid_region</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test constant offset with an invalid (reversed) region.&quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline_constant_offset</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y_flat</span><span class="p">,</span> <span class="n">offset_region_indices</span><span class="o">=</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span>
                <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;Invalid offset_region_indices&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">warn</span><span class="o">.</span><span class="n">message</span><span class="p">)</span> <span class="k">for</span> <span class="n">warn</span> <span class="ow">in</span> <span class="n">w</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">baseline</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">y_flat</span><span class="p">),</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_mono_exponential_fit">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_mono_exponential_fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_mono_exponential_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test the mono-exponential baseline fitting.&quot;&quot;&quot;</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">tau</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">3.0</span>
        <span class="n">true_baseline</span> <span class="o">=</span> <span class="n">_mono_exponential_decay_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">)</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">true_baseline</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span>

        <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">6.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">]</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">baseline_mono_exponential</span><span class="p">(</span>
            <span class="n">y_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertIsNotNone</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;y0&quot;</span><span class="p">],</span> <span class="n">y0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;A&quot;</span><span class="p">],</span> <span class="n">A</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;tau&quot;</span><span class="p">],</span> <span class="n">tau</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_stretched_exponential_fit">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_stretched_exponential_fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_stretched_exponential_fit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test the stretched exponential baseline fitting.&quot;&quot;&quot;</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">0.7</span>
        <span class="n">true_baseline</span> <span class="o">=</span> <span class="n">_stretched_exponential_decay_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">true_baseline</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaussian</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span>

        <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)]</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">baseline_stretched_exponential</span><span class="p">(</span>
            <span class="n">y_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">exclude_regions</span><span class="o">=</span><span class="n">exclude</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertIsNotNone</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;y0&quot;</span><span class="p">],</span> <span class="n">y0</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertAlmostEqual</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;beta&quot;</span><span class="p">],</span> <span class="n">beta</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_exponential_fit_insufficient_points">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_exponential_fit_insufficient_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_exponential_fit_insufficient_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test exponential fit behavior with too few points.&quot;&quot;&quot;</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">_mono_exponential_decay_model</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
            <span class="n">corrected</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">baseline_mono_exponential</span><span class="p">(</span>
                <span class="n">y_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">fit_region</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertTrue</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="s2">&quot;Not enough points&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">warn</span><span class="o">.</span><span class="n">message</span><span class="p">)</span> <span class="k">for</span> <span class="n">warn</span> <span class="ow">in</span> <span class="n">w</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertIsNone</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">testing</span><span class="o">.</span><span class="n">assert_array_equal</span><span class="p">(</span><span class="n">corrected</span><span class="p">,</span> <span class="n">y_data</span><span class="p">)</span></div>


<div class="viewcode-block" id="TestBaselineCorrection.test_input_validations">
<a class="viewcode-back" href="../../../api/generated/epyr.sub.baseline2.html#epyr.sub.baseline2.TestBaselineCorrection.test_input_validations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_input_validations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Test that functions raise ValueError on invalid input shapes.&quot;&quot;&quot;</span>
        <span class="n">y_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">baseline_polynomial</span><span class="p">(</span><span class="n">y_2d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">baseline_polynomial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">baseline_constant_offset</span><span class="p">(</span><span class="n">y_2d</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">baseline_mono_exponential</span><span class="p">(</span><span class="n">y_2d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">baseline_mono_exponential</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">x_data</span><span class="o">=</span><span class="n">y_2d</span><span class="p">)</span></div>
</div>



<span class="c1"># --- Main execution block ---</span>
<span class="c1"># This block runs when the script is executed directly.</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># First, run the visual examples to demonstrate functionality.</span>
    <span class="n">run_examples</span><span class="p">()</span>

    <span class="c1"># Second, run the unit tests to verify correctness.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">--- Running Unit Tests ---&quot;</span><span class="p">)</span>
    <span class="n">suite</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TestSuite</span><span class="p">()</span>
    <span class="n">suite</span><span class="o">.</span><span class="n">addTest</span><span class="p">(</span><span class="n">unittest</span><span class="o">.</span><span class="n">makeSuite</span><span class="p">(</span><span class="n">TestBaselineCorrection</span><span class="p">))</span>
    <span class="n">runner</span> <span class="o">=</span> <span class="n">unittest</span><span class="o">.</span><span class="n">TextTestRunner</span><span class="p">(</span><span class="n">verbosity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">runner</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">suite</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Sylvain Bertaina.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>