# epyrtools/baseline/_2d.py

"""
2D Baseline Correction Algorithms
=================================

This module contains the core functions for performing baseline correction on
2D data arrays (images, spectral maps). These functions are exposed to the
user through the `epyrtools.baseline` sub-package.

Currently, it provides a polynomial surface fitting method.
"""

import numpy as np
import warnings

# Import shared utility functions from within the same sub-package
from ._utils import _create_fit_mask_2d

# --- 2D Baseline Correction Helpers ---

def _polynomial_features_2d(
    x_coords: np.ndarray,
    y_coords: np.ndarray,
    order_x: int,
    order_y: int
) -> np.ndarray:
    """Generates a 2D polynomial design matrix (Vandermonde-like).

    For each pair `(x, y)` in the input coordinates, this function creates a row
    containing all polynomial terms `x^i * y^j` where `0<=i<=order_x` and
    `0<=j<=order_y`. The ordering is row-major on `j`, then `i`, i.e.,
    `[1, y, y^2, ..., x, xy, xy^2, ..., x^2, x^2y, ...]`.

    Args:
        x_coords (np.ndarray): 1D array of x-coordinates.
        y_coords (np.ndarray): 1D array of y-coordinates of the same length.
        order_x (int): Maximum polynomial order for the x-dimension.
        order_y (int): Maximum polynomial order for the y-dimension.

    Returns:
        np.ndarray:
            The design matrix where each row corresponds to an `(x,y)` pair and
            columns are the polynomial feature terms.
    """
    if x_coords.ndim != 1 or y_coords.ndim != 1 or len(x_coords) != len(y_coords):
        raise ValueError("x_coords and y_coords must be 1D arrays of the same length.")
    if order_x < 0 or order_y < 0:
        raise ValueError("Polynomial orders must be non-negative.")

    num_points = len(x_coords)
    num_coeffs = (order_x + 1) * (order_y + 1)
    design_matrix = np.zeros((num_points, num_coeffs))

    col_idx = 0
    for i in range(order_x + 1):
        for j in range(order_y + 1):
            design_matrix[:, col_idx] = (x_coords**i) * (y_coords**j)
            col_idx += 1
    return design_matrix

def _evaluate_polynomial_surface(
    x_mesh: np.ndarray,
    y_mesh: np.ndarray,
    coeffs: np.ndarray,
    order_x: int,
    order_y: int
) -> np.ndarray:
    """Evaluates a 2D polynomial surface on a coordinate grid.

    Args:
        x_mesh (np.ndarray): 2D mesh of x-coordinates (e.g., from `np.meshgrid`).
        y_mesh (np.ndarray): 2D mesh of y-coordinates.
        coeffs (np.ndarray): 1D array of polynomial coefficients, ordered as
                             generated by `_polynomial_features_2d`.
        order_x (int): Maximum order for x used to generate `coeffs`.
        order_y (int): Maximum order for y used to generate `coeffs`.

    Returns:
        np.ndarray: The evaluated 2D polynomial surface with the same shape
                    as `x_mesh` and `y_mesh`.
    """
    if x_mesh.shape != y_mesh.shape:
        raise ValueError("x_mesh and y_mesh must have the same shape.")
    if coeffs.ndim != 1:
        raise ValueError("coeffs must be a 1D array.")
    
    expected_num_coeffs = (order_x + 1) * (order_y + 1)
    if len(coeffs) != expected_num_coeffs:
        raise ValueError(
            f"Number of coefficients ({len(coeffs)}) does not match "
            f"expected for orders ({order_x}, {order_y}), which is {expected_num_coeffs}."
        )

    surface = np.zeros_like(x_mesh, dtype=float)
    coeff_idx = 0
    for i in range(order_x + 1):
        for j in range(order_y + 1):
            surface += coeffs[coeff_idx] * (x_mesh**i) * (y_mesh**j)
            coeff_idx += 1
    return surface

# --- Public 2D Baseline Correction Function ---

def baseline_polynomial_2d(
    z_data: np.ndarray,
    x_data: np.ndarray = None,
    y_data: np.ndarray = None,
    poly_order: int | tuple[int, int] = (1, 1),
    exclude_regions: list[tuple[tuple[float, float], tuple[float, float]]] = None,
    roi: tuple[tuple[float, float], tuple[float, float]] = None
) -> tuple[np.ndarray, np.ndarray]:
    """Performs 2D baseline correction by subtracting a fitted polynomial surface.

    The polynomial surface is fitted to regions of the data presumed to be baseline.
    These regions are defined by an overall region of interest (ROI) and/or by
    excluding specific rectangular signal regions.

    Args:
        z_data (np.ndarray): The 2D data array (e.g., image, spectral map).
        x_data (np.ndarray, optional): 1D array of x-axis coordinates
            corresponding to the columns of `z_data`. If None, column indices are used.
        y_data (np.ndarray, optional): 1D array of y-axis coordinates
            corresponding to the rows of `z_data`. If None, row indices are used.
        poly_order (int or tuple[int, int], optional): Order of the polynomial.
            If an int, it's used for both x and y orders: `(order, order)`.
            If a tuple `(order_x, order_y)`, it specifies the maximum order for
            x and y terms, respectively. Defaults to (1, 1) (a tilted plane).
        exclude_regions (list of tuples, optional): List of rectangular regions
            to *exclude* from baseline fitting. Each region is defined as
            `((x_start, x_end), (y_start, y_end))`. Interpreted in `x_data`/`y_data`
            units or indices. Defaults to None.
        roi (tuple, optional): A single rectangular region `((x_start, x_end), (y_start, y_end))`
            specifying where baseline fitting should *occur*. Data outside this
            ROI is not used. Interpreted in `x_data`/`y_data` units or indices.
            If None, the entire dataset (minus `exclude_regions`) is used.
            Defaults to None.

    Returns:
        tuple[np.ndarray, np.ndarray]:
            A tuple containing:
            - **z_corrected** (np.ndarray): The baseline-corrected 2D data.
            - **baseline_surface** (np.ndarray): The calculated 2D polynomial baseline.

    Raises:
        ValueError: If inputs are invalid.
    """
    if not isinstance(z_data, np.ndarray) or z_data.ndim != 2:
        raise ValueError("z_data must be a 2D NumPy array.")

    rows, cols = z_data.shape

    # Parse polynomial order
    if isinstance(poly_order, int):
        order_x, order_y = poly_order, poly_order
    elif isinstance(poly_order, tuple) and len(poly_order) == 2:
        order_x, order_y = poly_order
        if not (isinstance(order_x, int) and isinstance(order_y, int) and order_x >= 0 and order_y >= 0):
            raise ValueError("poly_order tuple elements must be non-negative integers.")
    else:
        raise ValueError("poly_order must be an int or a tuple of two ints.")

    # Prepare coordinate axes for fitting and evaluation
    x_coords_eval = x_data if x_data is not None else np.arange(cols)
    y_coords_eval = y_data if y_data is not None else np.arange(rows)

    if len(x_coords_eval) != cols or x_coords_eval.ndim != 1:
        raise ValueError(f"x_data must be a 1D array of length {cols} (num columns).")
    if len(y_coords_eval) != rows or y_coords_eval.ndim != 1:
        raise ValueError(f"y_data must be a 1D array of length {rows} (num rows).")

    # Validate region formats
    region_format_error = "must be a tuple of ((x_start, x_end), (y_start, y_end))."
    if roi is not None:
        if not (isinstance(roi, tuple) and len(roi) == 2 and isinstance(roi[0], tuple) and
                len(roi[0]) == 2 and isinstance(roi[1], tuple) and len(roi[1]) == 2):
            raise ValueError(f"roi {region_format_error}")
    if exclude_regions is not None:
        if not isinstance(exclude_regions, list):
            raise ValueError("exclude_regions must be a list of region tuples.")
        for i, region in enumerate(exclude_regions):
            if not (isinstance(region, tuple) and len(region) == 2 and
                    isinstance(region[0], tuple) and len(region[0]) == 2 and
                    isinstance(region[1], tuple) and len(region[1]) == 2):
                raise ValueError(f"Each item in exclude_regions (item {i}) {region_format_error}")

    # Create coordinate meshgrid for full surface evaluation
    XX_eval, YY_eval = np.meshgrid(x_coords_eval, y_coords_eval)

    # Create the 2D mask indicating which points to use for fitting
    fit_mask = _create_fit_mask_2d(
        shape=z_data.shape,
        x_axis_coords=x_coords_eval,
        y_axis_coords=y_coords_eval,
        fit_window_roi=roi,
        exclude_regions=exclude_regions
    )

    # Select the points for fitting based on the mask (flattened to 1D)
    x_points_to_fit = XX_eval[fit_mask]
    y_points_to_fit = YY_eval[fit_mask]
    z_values_to_fit = z_data[fit_mask]

    num_points_for_fit = len(z_values_to_fit)
    num_coeffs_needed = (order_x + 1) * (order_y + 1)

    if num_points_for_fit < num_coeffs_needed:
        warnings.warn(
            f"Not enough points ({num_points_for_fit}) for polynomial fit with "
            f"orders ({order_x}, {order_y}), which requires {num_coeffs_needed} coefficients. "
            "Returning original data.", UserWarning
        )
        return z_data, np.zeros_like(z_data)

    # Construct the design matrix and perform the least-squares fit
    design_matrix = _polynomial_features_2d(x_points_to_fit, y_points_to_fit, order_x, order_y)
    try:
        coeffs, _, rank, _ = np.linalg.lstsq(design_matrix, z_values_to_fit, rcond=None)
        
        if rank < num_coeffs_needed:
             warnings.warn(
                f"Polynomial fit may be poorly conditioned. Rank deficiency detected: "
                f"rank={rank}, expected_coeffs={num_coeffs_needed}. Results might be unreliable.",
                UserWarning
            )

        # Evaluate the fitted surface over the entire grid and subtract
        baseline_surface = _evaluate_polynomial_surface(XX_eval, YY_eval, coeffs, order_x, order_y)
        z_corrected = z_data - baseline_surface
        return z_corrected, baseline_surface

    except np.linalg.LinAlgError as e:
        warnings.warn(f"Polynomial surface fit failed: {e}. Returning original data.", UserWarning)
        return z_data, np.zeros_like(z_data)